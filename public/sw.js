// Service Worker for YourTrainer PWA - Optimized v1.3.0\nconst CACHE_VERSION = '1.3.0';\nconst STATIC_CACHE_NAME = `yourtrainer-static-v${CACHE_VERSION}`;\nconst DYNAMIC_CACHE_NAME = `yourtrainer-dynamic-v${CACHE_VERSION}`;\nconst IMAGE_CACHE_NAME = `yourtrainer-images-v${CACHE_VERSION}`;\n\n// Cache stratejileri\nconst CACHE_STRATEGIES = {\n  CACHE_FIRST: 'cache-first',\n  NETWORK_FIRST: 'network-first',\n  STALE_WHILE_REVALIDATE: 'stale-while-revalidate'\n};\n\n// Önbellek konfigürasyonları\nconst CACHE_CONFIGS = {\n  STATIC: {\n    name: STATIC_CACHE_NAME,\n    strategy: CACHE_STRATEGIES.CACHE_FIRST,\n    maxAge: 30 * 24 * 60 * 60 * 1000, // 30 gün\n    maxEntries: 50\n  },\n  DYNAMIC: {\n    name: DYNAMIC_CACHE_NAME,\n    strategy: CACHE_STRATEGIES.STALE_WHILE_REVALIDATE,\n    maxAge: 24 * 60 * 60 * 1000, // 1 gün\n    maxEntries: 30\n  },\n  IMAGES: {\n    name: IMAGE_CACHE_NAME,\n    strategy: CACHE_STRATEGIES.CACHE_FIRST,\n    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 gün\n    maxEntries: 100\n  }\n};\n\n// Kritik statik dosyalar (hemen cache'lenecek)\nconst CRITICAL_ASSETS = [\n  '/',\n  '/index.html',\n  '/manifest.json',\n  '/logo.svg'\n];\n\n// Runtime cache pattern'leri\nconst CACHE_PATTERNS = [\n  { \n    pattern: /\\.(js|css)$/,\n    config: CACHE_CONFIGS.STATIC\n  },\n  { \n    pattern: /\\.(png|jpg|jpeg|svg|gif|webp|ico)$/i,\n    config: CACHE_CONFIGS.IMAGES\n  },\n  { \n    pattern: /\\/(dashboard|clients|profile)/,\n    config: CACHE_CONFIGS.DYNAMIC\n  }\n];\n\n// Service Worker Install Event\nself.addEventListener('install', (event) => {\n  console.log(`[SW] Installing service worker v${CACHE_VERSION}...`);\n  \n  event.waitUntil(\n    Promise.all([\n      // Kritik dosyaları cache'le\n      caches.open(STATIC_CACHE_NAME)\n        .then((cache) => {\n          console.log('[SW] Caching critical assets...');\n          return cache.addAll(CRITICAL_ASSETS);\n        }),\n      // Hemen aktif hale getir\n      self.skipWaiting()\n    ])\n    .then(() => {\n      console.log('[SW] Critical assets cached successfully');\n    })\n    .catch((error) => {\n      console.error('[SW] Failed to cache critical assets:', error);\n    })\n  );\n});\n\n// Service Worker Activate Event\nself.addEventListener('activate', (event) => {\n  console.log(`[SW] Activating service worker v${CACHE_VERSION}...`);\n  \n  event.waitUntil(\n    Promise.all([\n      // Eski cache'leri temizle\n      cleanupOldCaches(),\n      // Tüm clientları kontrol et\n      self.clients.claim()\n    ])\n  );\n});\n\n// Eski cache'leri temizleme\nasync function cleanupOldCaches() {\n  const cacheNames = await caches.keys();\n  const validCacheNames = [STATIC_CACHE_NAME, DYNAMIC_CACHE_NAME, IMAGE_CACHE_NAME];\n  \n  const deletePromises = cacheNames\n    .filter(cacheName => \n      cacheName.startsWith('yourtrainer-') && \n      !validCacheNames.includes(cacheName)\n    )\n    .map(cacheName => {\n      console.log('[SW] Deleting old cache:', cacheName);\n      return caches.delete(cacheName);\n    });\n  \n  return Promise.all(deletePromises);\n}\n\n// Fetch Event - İstek yakalama ve cache stratejileri\nself.addEventListener('fetch', (event) => {\n  const { request } = event;\n  const url = new URL(request.url);\n  \n  // Sadece aynı origin isteklerini handle et\n  if (url.origin !== location.origin || request.method !== 'GET') {\n    return;\n  }\n\n  event.respondWith(handleRequest(request));\n});\n\n// Ana istek handling fonksiyonu\nasync function handleRequest(request) {\n  const url = new URL(request.url);\n  \n  try {\n    // Cache pattern'ine göre strateji belirle\n    const cacheConfig = getCacheConfig(url.pathname);\n    \n    switch (cacheConfig.strategy) {\n      case CACHE_STRATEGIES.CACHE_FIRST:\n        return await cacheFirst(request, cacheConfig);\n      \n      case CACHE_STRATEGIES.NETWORK_FIRST:\n        return await networkFirst(request, cacheConfig);\n      \n      case CACHE_STRATEGIES.STALE_WHILE_REVALIDATE:\n      default:\n        return await staleWhileRevalidate(request, cacheConfig);\n    }\n  } catch (error) {\n    console.error('[SW] Error handling request:', error);\n    return handleOfflineFallback(request);\n  }\n}\n\n// Cache konfigürasyonu belirleme\nfunction getCacheConfig(pathname) {\n  for (const { pattern, config } of CACHE_PATTERNS) {\n    if (pattern.test(pathname)) {\n      return config;\n    }\n  }\n  return CACHE_CONFIGS.DYNAMIC; // Default\n}\n\n// Cache First Stratejisi\nasync function cacheFirst(request, config) {\n  const cache = await caches.open(config.name);\n  const cachedResponse = await cache.match(request);\n  \n  if (cachedResponse && !isExpired(cachedResponse, config.maxAge)) {\n    return cachedResponse;\n  }\n  \n  try {\n    const networkResponse = await fetch(request);\n    if (networkResponse.ok) {\n      await cache.put(request, networkResponse.clone());\n      await limitCacheSize(config.name, config.maxEntries);\n    }\n    return networkResponse;\n  } catch (error) {\n    if (cachedResponse) {\n      console.log('[SW] Serving stale cache due to network error');\n      return cachedResponse;\n    }\n    return handleOfflineFallback(request);\n  }\n}\n\n// Network First Stratejisi\nasync function networkFirst(request, config) {\n  try {\n    const networkResponse = await Promise.race([\n      fetch(request),\n      new Promise((_, reject) => \n        setTimeout(() => reject(new Error('Network timeout')), 3000)\n      )\n    ]);\n    \n    if (networkResponse.ok) {\n      const cache = await caches.open(config.name);\n      await cache.put(request, networkResponse.clone());\n      await limitCacheSize(config.name, config.maxEntries);\n    }\n    return networkResponse;\n  } catch (error) {\n    console.log('[SW] Network failed, trying cache...');\n    const cache = await caches.open(config.name);\n    const cachedResponse = await cache.match(request);\n    return cachedResponse || handleOfflineFallback(request);\n  }\n}\n\n// Stale While Revalidate Stratejisi\nasync function staleWhileRevalidate(request, config) {\n  const cache = await caches.open(config.name);\n  const cachedResponse = await cache.match(request);\n  \n  // Arka planda güncelleme\n  const fetchPromise = fetch(request)\n    .then(async (networkResponse) => {\n      if (networkResponse.ok) {\n        await cache.put(request, networkResponse.clone());\n        await limitCacheSize(config.name, config.maxEntries);\n      }\n      return networkResponse;\n    })\n    .catch((error) => {\n      console.log('[SW] Background fetch failed:', error);\n    });\n  \n  // Cache varsa onu döndür, yoksa network'ü bekle\n  if (cachedResponse && !isExpired(cachedResponse, config.maxAge)) {\n    return cachedResponse;\n  }\n  \n  try {\n    return await fetchPromise;\n  } catch (error) {\n    return cachedResponse || handleOfflineFallback(request);\n  }\n}\n\n// Cache expiry kontrolü\nfunction isExpired(response, maxAge) {\n  if (!maxAge) return false;\n  \n  const dateHeader = response.headers.get('date');\n  if (!dateHeader) return false;\n  \n  const cacheDate = new Date(dateHeader);\n  const now = new Date();\n  return (now.getTime() - cacheDate.getTime()) > maxAge;\n}\n\n// Offline fallback handling\nasync function handleOfflineFallback(request) {\n  const url = new URL(request.url);\n  \n  // SPA rotaları için index.html döndür\n  if (url.pathname.startsWith('/dashboard') || \n      url.pathname.startsWith('/clients') || \n      url.pathname.startsWith('/profile')) {\n    const cache = await caches.open(STATIC_CACHE_NAME);\n    const fallback = await cache.match('/index.html');\n    if (fallback) return fallback;\n  }\n  \n  // Resimler için placeholder\n  if (/\\.(png|jpg|jpeg|svg|gif|webp)$/i.test(url.pathname)) {\n    return new Response(\n      '<svg width=\"200\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"200\" height=\"200\" fill=\"#f3f4f6\"/><text x=\"50%\" y=\"50%\" text-anchor=\"middle\" fill=\"#9ca3af\">Çevrimdışı</text></svg>',\n      { headers: { 'Content-Type': 'image/svg+xml' } }\n    );\n  }\n  \n  // Genel hata response\n  return new Response(\n    JSON.stringify({\n      error: 'Çevrimdışı',\n      message: 'Bu sayfa çevrimdışı modda kullanılamıyor.'\n    }),\n    {\n      status: 503,\n      statusText: 'Service Unavailable',\n      headers: { 'Content-Type': 'application/json; charset=utf-8' }\n    }\n  );\n}\n\n// Cache boyut sınırlama (LRU)\nasync function limitCacheSize(cacheName, maxEntries) {\n  const cache = await caches.open(cacheName);\n  const keys = await cache.keys();\n  \n  if (keys.length > maxEntries) {\n    const deleteCount = keys.length - maxEntries;\n    const deletePromises = keys\n      .slice(0, deleteCount)\n      .map(key => cache.delete(key));\n    \n    await Promise.all(deletePromises);\n    console.log(`[SW] Cache ${cacheName} cleaned up: ${deleteCount} items removed`);\n  }\n}\n\n// Background Sync (gelecek özellik)\nself.addEventListener('sync', (event) => {\n  console.log('[SW] Background sync triggered:', event.tag);\n  \n  if (event.tag === 'background-sync') {\n    event.waitUntil(doBackgroundSync());\n  }\n});\n\nasync function doBackgroundSync() {\n  // Offline'da yapılan değişiklikleri senkronize et\n  console.log('[SW] Background sync completed');\n}\n\n// Message handling\nself.addEventListener('message', (event) => {\n  if (event.data && event.data.type === 'SKIP_WAITING') {\n    self.skipWaiting();\n  }\n});\n\nconsole.log(`[SW] Service Worker v${CACHE_VERSION} loaded successfully`);