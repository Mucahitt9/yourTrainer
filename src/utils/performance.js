// Performance utilities for YourTrainer\n\n// Image optimization utility\nexport const optimizeImage = (file, options = {}) => {\n  const {\n    maxWidth = 1000,\n    maxHeight = 1000,\n    quality = 0.8,\n    format = 'jpeg'\n  } = options;\n\n  return new Promise((resolve, reject) => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    const img = new Image();\n\n    img.onload = () => {\n      // Calculate new dimensions\n      let { width, height } = img;\n      \n      if (width > height) {\n        if (width > maxWidth) {\n          height = (height * maxWidth) / width;\n          width = maxWidth;\n        }\n      } else {\n        if (height > maxHeight) {\n          width = (width * maxHeight) / height;\n          height = maxHeight;\n        }\n      }\n\n      canvas.width = width;\n      canvas.height = height;\n\n      // Draw and compress\n      ctx.drawImage(img, 0, 0, width, height);\n      \n      // Convert to blob\n      canvas.toBlob(\n        (blob) => {\n          resolve({\n            blob,\n            dataUrl: canvas.toDataURL(`image/${format}`, quality),\n            width,\n            height,\n            originalSize: file.size,\n            compressedSize: blob.size,\n            compressionRatio: Math.round((1 - blob.size / file.size) * 100)\n          });\n        },\n        `image/${format}`,\n        quality\n      );\n    };\n\n    img.onerror = reject;\n    img.src = URL.createObjectURL(file);\n  });\n};\n\n// Performance measurement utility\nexport const measurePerformance = (name, fn) => {\n  return async (...args) => {\n    const start = performance.now();\n    const result = await fn(...args);\n    const end = performance.now();\n    \n    console.log(`âš¡ ${name} took ${Math.round(end - start)}ms`);\n    return result;\n  };\n};\n\n// Debounce utility for performance\nexport const debounce = (func, wait) => {\n  let timeout;\n  return function executedFunction(...args) {\n    const later = () => {\n      clearTimeout(timeout);\n      func(...args);\n    };\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n};\n\n// Throttle utility for performance\nexport const throttle = (func, limit) => {\n  let inThrottle;\n  return function() {\n    const args = arguments;\n    const context = this;\n    if (!inThrottle) {\n      func.apply(context, args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n};\n\n// Local storage with compression\nexport const compressedStorage = {\n  setItem: (key, value) => {\n    try {\n      const compressed = JSON.stringify(value);\n      localStorage.setItem(key, compressed);\n      return true;\n    } catch (error) {\n      console.error('Storage compression failed:', error);\n      return false;\n    }\n  },\n  \n  getItem: (key, defaultValue = null) => {\n    try {\n      const compressed = localStorage.getItem(key);\n      return compressed ? JSON.parse(compressed) : defaultValue;\n    } catch (error) {\n      console.error('Storage decompression failed:', error);\n      return defaultValue;\n    }\n  },\n  \n  removeItem: (key) => {\n    localStorage.removeItem(key);\n  },\n  \n  clear: () => {\n    localStorage.clear();\n  }\n};\n\n// Memory usage monitoring\nexport const getMemoryUsage = () => {\n  if ('memory' in performance) {\n    const memory = performance.memory;\n    return {\n      used: Math.round(memory.usedJSHeapSize / 1024 / 1024),\n      total: Math.round(memory.totalJSHeapSize / 1024 / 1024),\n      limit: Math.round(memory.jsHeapSizeLimit / 1024 / 1024),\n      percentage: Math.round((memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100)\n    };\n  }\n  return null;\n};\n\n// Bundle size analyzer utility\nexport const analyzeBundleSize = () => {\n  const scripts = Array.from(document.scripts);\n  const styles = Array.from(document.querySelectorAll('link[rel=\"stylesheet\"]'));\n  \n  console.group('ðŸ“¦ Bundle Analysis');\n  console.log('ðŸ“„ Scripts:', scripts.length);\n  console.log('ðŸŽ¨ Stylesheets:', styles.length);\n  \n  // Estimate total size (approximate)\n  let totalEstimatedSize = 0;\n  scripts.forEach((script, index) => {\n    if (script.src) {\n      console.log(`JS ${index + 1}: ${script.src}`);\n    }\n  });\n  \n  styles.forEach((style, index) => {\n    if (style.href) {\n      console.log(`CSS ${index + 1}: ${style.href}`);\n    }\n  });\n  \n  console.groupEnd();\n};\n\n// Intersection Observer utility for lazy loading\nexport const createIntersectionObserver = (callback, options = {}) => {\n  const defaultOptions = {\n    root: null,\n    rootMargin: '50px',\n    threshold: 0.1\n  };\n  \n  const config = { ...defaultOptions, ...options };\n  \n  return new IntersectionObserver((entries) => {\n    entries.forEach((entry) => {\n      if (entry.isIntersecting) {\n        callback(entry);\n      }\n    });\n  }, config);\n};\n\n// Resource hints utility\nexport const addResourceHint = (href, rel = 'prefetch', as = null) => {\n  const link = document.createElement('link');\n  link.rel = rel;\n  link.href = href;\n  \n  if (as) {\n    link.as = as;\n  }\n  \n  if (rel === 'preload') {\n    link.crossOrigin = 'anonymous';\n  }\n  \n  document.head.appendChild(link);\n};\n\n// Performance metrics collector\nexport const collectPerformanceMetrics = () => {\n  return {\n    timing: performance.timing,\n    navigation: performance.navigation,\n    memory: getMemoryUsage(),\n    entries: performance.getEntries(),\n    now: performance.now()\n  };\n};